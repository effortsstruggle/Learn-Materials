
错误:
	编译错误:
		1.编译
		2.链接
	运行错误:
	

一、程序=数据(数据结构)+算法

二、类型:三大基本类型 + 复杂类型
		基本类型:
			整型(int,short,long)  -- 浮点型(float , double) -- 字符型(char)
		复杂类型:
			结构体(struct)
	

三、变量:(知识点:定义变量，初始化变量,引用变量, 32个关键字)

		1.定义变量 : 分配空间
			类型 变量名;   
			int  a;
			
			定义变量默认是有符号且是动态:
				auto signed int a;  等价于:int a;
			
		PS:
			C规定，标识符只能是字母(A～Z，a～z)、数字(0～9)、下划线(_)组成的字符串
			并且其第一个字符必须是字母或下划线。且不能与C语言的关键字重名
		
		
		2.初始化变量:定义的同时赋初值
			int a = 10;

		3.引用变量:通过变量名引用变量空间的内容(引用的空间长度由类型决定)
			如：printf("%d",a);
			
			
			PS:1、使用变量，必须先定义。
			
			C语言中的32个关键字
		auto		double	int			struct
		break		else	long		switch
		case		enum	register	typedef
		char		extern	return		union
		const		float	short		unsigned
		continue	for		signed		void
		default		goto	sizeof		volatile
		do			if		static		while
		
四、运算符：(
				知识点1： 结合性,优先级,溢出，运算符表达式及结果
				知识点2： 运算符分类:
							1.空间长度运算符:sizeof
							2.赋值运算符： =
							3、算术运算符：+ - * / % 
							4、隐式类型转换以及强转（强制类型转换）	
							5、判断运算符：>  <  >=  <=  !=   ==
							6、逻辑运算符：&& || ！
							7、三目运算符： 表达式1?表达式2:表达式3
							8、自增自减： ++  --
							9、优先级运算符	（）
							10.位运算符（<<  >>  & | ~ ^）
			)


	结合性  :计算的顺序
	优先级  ：https://www.cnblogs.com/jiu0821/p/7347299.html

	溢出  ：同类型  高位 转 低位时（如：int值---》short值）
	
	运算符表达式： 1+1  结果：运算结果
		表达式（expression）
		语句（statement）
		1
	1、求空间长度sizeof
		sizeof  类型/变量名
		结果：空间长度
	
	2赋值运算符： =
			结果:赋值结果
	3、算术运算符：+ - * / % 	
			结果：算数结果
	4、隐式类型转换：(C语言是强类型，在运算过程，必须转换为同类型才能运算)
			1、大小不一：将小位转高位
				short-->int
				char--->int
				float-->double
			
			2、不同类型：
				int---double
				signed   -- 》 unsigned

				两个short比较  -- >  转换成 int  比较
	强制类型转换：由程序决定类型
		(类型)表达式

	5、判断运算符：>  <  >=  <=  !=   ==  结果：真1    假0
	
	6、逻辑运算符：  表达式1||表达式2   &&短路与  ！    （从左往右）
				结果：真1    假0
	7、三目运算符： 
			表达式1?表达式2:表达式3
			
			结果：若表达式1为真，结果就为表达式2的结果，否则为表达式3的结果
	8、自增自减： ++  --   (将自身值+1）
		i=0
		前自增：  ++i   结果=1  i=1    总结：(i)先自加，(结果)后取值
		后自增：  i++   结果=0  i=1    总结：（结果）先取值,（i）再自加

	9、优先级运算符:有括号先执行括号，先内再外
		 (表达式)
		 
	10.位运算符:（操作二进制位）
		1.  左移    n<<n  数据<<n：将空间中的bit向移移动n位（移出的部分舍弃，移进来的部分用0补充）
				结果：左移空间的内容	
		2.  右移： 数据>>n （和左移相同）
		
		3.  &    按位与（一０得０）
			|    按位或（一1得1）
		
		4、按位取反：(4bit)    a=5 (101)   ~a=2 (010) 	
					如：原:011  
						取反后：~011 = 100
		5、^(异或) （两个二进制位不同时为真）
					如：原:   011 
							^ 110
							-------
					  异或后：101
					  
五、流程控制：（知识点:1.顺序流程,2.选择流程,3.循环流程,4.流程控制）

	1.顺序流程：代码从上往下逐条执行。
	2.选择流程：当条件成立才执行某语句或者语句块
		
		2.1单分支：
		  if(表件表达式)
			语句或者语句块1
		  注：当条件表达式为真时，则执行语句或者语句块1。若为则时，则不执行
		  
		2.2双分支：
			if(条件表达式1)
				语句或者语句块1
			else //上面条件不成立时，执行下面的else
				语句或者语句块2
		2.3多分支：多个条件	
		
			if(条件表达式1)
				语句或者语句块1
			else if(条件表达式2) 
				语句或者语句块2
			...
			else if(条件表达式n)
				语句或者语句块2
			else 
				语句或者语句块2	
				
		2.4多分支：		
		  switch(字符或者整型表达式1)  
		  {
				case 常量：	//表达式1的结果匹配此常量
				break;
				default://上面条件不成立时，执行此default
				
		  }
		//注  1、{}不能忘记
			  2、break是每一个条分支的结束语，没有break一直执行
		2.5 嵌套的if
			if(..)
			{
				if(...)
				{
					...
				}
				
			}  		  
	3.循环流程：当条件成立时，重复执行
			1、for循环
				for(初始化表达式1;结束表达式2;过程表达式)
					语句或者语句块1;
				其他语句;
				第一循环时：执行初始化表达式1，判断该条件2是否成立，成立则执行
				其他循环：执行初始化表达式3，判断该条件是2否成立，成立则执行
				
				for(初始化表达式1;结束表达式2;过程表达式)
				{
					//嵌套if或者其他语句
					if（）
					{
					}
				}
				for(初始化表达式1;结束表达式2;过程表达式)//第一层循环
				{
						for(初始化表达式1;结束表达式2;过程表达式)//第二层循环
						{
							//
						}
				}
			2、while(条件表达式)  //条件表达式为真时，则继续循环
			   {
				 循环体;
			   }
				注：必须注意初始化状态，结束状态，和过程状态
				
			3、do-while    注：必须关注起始状态
				do  //先执行 
				{
					循环体；
				}while;(条件表达式)  后判断
		
	 4、循环控制： 
			结束本次循环contine:直接跳出本次循环，开始下一次循环
			结束本层循环break：直接跳出本层循环
		注：一个for或者while或者do-while循环就是一层循环

六、数组（1.数组的定义,2.数组初始化,3.引用数组）
	1.数组：一块“连续”且同类型的空间
	2.
		2.1定义数组：
			类型 数组名[长度]; //这个可以不初始化
			类型 数组名[]={...};//必须初始化，由于初始化元素来决定数组的长度
	
		PS:分配的空间长度   sizeof(类型)*长度
	  
			数组名：是首地址，常量

		2.2、初始化：在定义数组同时赋值 
			PS:只初始化部分值时，未被初始化的元素值为0
			
			
		2.3、引用：不能整体引用，只能一个一个元素地引用
			数组名[下标];   
			PS：下标是从0开始的
			
			
		PS：在定义数组的时必须初始化，否则只能一个一个的赋值（因为数组名是首地址）
			int buf[10];
			buf={1,2,3,4};错误的写法
			
			
七、字符数组与字符串（知识点:字符数组,字符串）
	1.字符数组：（变量字符数组）
		1.1、定义字符数组：
			char buf[10];
			buf="abc";//错的,使用字符串赋值，只能在定义的时候初始化，
			因为数组名是首地址，只能在定义的时候整体赋值，否则只能一个一个赋值
			
		
		1.2、初始化：在初始化时，尽量添加‘ \0 ’
			char buf[]={'a','b','\0'};
			char buf[]="abc";//结尾默认有‘\0’
			char buf1[5]={'2','a',2','a'};//定义的长度为5 ， 但只给了4个值 ， 最后一位用‘\0’补充
			
		1.3、引用：不能整体引用，只能一个一个元素地引用
		
		PS:字符串通常是通过'\0'代表字符串的结束（字符串或数组必须添加 \0  来代表结束）
		
	2.字符串： 常量字符数组  (就是首地址---一块连续的空间)
			"lifei"  
			PS：编译会所有字符串末尾添加 \0 
			
		字符串：就是一连串字符，表达式的结果为一个地址,地址空间都是常量空间(常量空间不能修改)

		char* p="abc";//p存放的是 "abc的首地址 也就是a的地址 "   




八：函数以及递归：（知识点:1.定义函数,2.递归）

		1.自定义函数：用户自已经定义一个功能接口
		
			1.1定义函数：
				返回值类型 函数名(形参列表)
				{
					return 表达式;
				}
				PS:1.定义函数只是描述了一个功能过程，不会执行
				
				   2.表达式必须放在函数内
					
				   3.main函数：是主函数（程序的入口函数）
				
				
				自定义函数的两种格式:
					1、无返回值  无形参列表
						void 函数名(void)
						{
							...
						}
					2、有返回值，无形参
						类型 函数名(void)
						{
							...
						}
			1.2调用函数：执行一次函数 
					函数名();  
			
		2.递归：自己调用自己　　（难度比较大：２周的时间）
			.. fun(..)
			{
				...
				fun(...);
				...
			}
			
			PS:  2when  1what
				when从什么时候开始  
				when到什么时候结束
				what每个“梦境”执行的过程（难）
				
			PS：谁调用a函数，就返回给谁
				递归给while循环类似，每递归一次就是每循环一次
				
				
九、数据区 ：(知识点:1.作用域,2.生命周期)
	
	进程区域划分:
		对于一个进程的内存空间而言，可以在逻辑上分成3个部份：代码区，静态数据区和动态数据区。	
		
	程序=数据(数据结构)+算法   ---》 每一个数据都是有作用域和生命周期的
	 １、作用域：能被引用的区间    引用：能看到名字称为引用
		（从空间角度分析：作用范围）
			
		局部变量（内部变量）：在函数内定义的变量（作用域在函数内）
				1.形参
				2.函数内定义
		全局变量（外部变量）：在函数外定义的变量（作用域在本文件中）		
		
		PS:引用变量时，必须保证 该变量的作用域存在  和  生命周期存在-----------引用时，必须作用域存在
		   （在同一个作用域中）不能同名定义
		   若全局与局部作用域重叠，局部变量优先
   　２、生命周期：
		（从时间角度分析：生存时间）
	
		 1.动态区(栈区):函数开始调用时，则分配空间；函数调用结束则释放空间
				1、在函数内定义  auto变量(定义变量时，默认就是auto 变量)(内部变量也叫本地变量)
				2、形参变量
				作用:存放函数的参数值，局部变量的值等
				
		 2静态区：程序一运行就开始分配，程序结束则释放
				1、全局变量（外部变量）
				2、static变量
				
				作用:全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域（内存是连续的），
					 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域
					 
		 3堆区:程序员空间(程序员申请，程序员释放)		
				它和数据结构中的堆是两回事
				
		 4.文字常量区:常量字符串就是放在这里的。 
						程序结束后由系统释放
				
			动态数据区一般就是“堆  栈”。
			“栈(stack)”和“堆(heap)”是两种不同的动态数据区，
			栈是一种线性结构(空间连续)，堆是一种链式结构(空间不连续)

十、宏及函数声明（知识点:
						1.函数声明		
						2.头文件	
						3.宏
						4.条件宏
						5.宏的应用
				 ）

	1.函数定义：
		返回类型  函数名（...）
		{
			...
		}
	2.函数声明:作用只是用于告诉编译器，该调用的名字是一个函数
				//调用函数时，必须要声明

			1.本文件声明：
				返回类型  函数名（...）;
				
			2.外文件函数声名： 向外界提供头文件
				extern 返回类型  函数名（...）; 形参类型
			
			PS：凡是调用函数时，必须存在声明。
			
	3.头文件（.h文件）：作用是存放函数的声明，类型的定义等	
		#include<头文件>	  系统下查找
		#include "头文件"     本路径下查找，再系统下查找
		
		PS:作用：在预处理时，进行简单的文件包含
		
		
		
	预处理：编译器在编译源文件之前处理的任务
	1、宏：只是一个简单的替换  
		ps : 宏一定不能加“;”
		1.1 定义宏:   (初始化宏)
			0、空宏值
				#define 宏名  
			1、无参数的宏
				#define 宏名  值
				PS：由于宏不是一个语句，不能加分号	
					宏名：大写（为了与变量名）
			2、带参数的宏
				#define 宏名(x,y)  ((x)+(y))
		1.2 引用宏:
			宏名(参数)
					

	2.条件宏（宏选择）：
		2.1第一种形式如下: 
			#ifdef 标识符(宏名)
				程序段 1 
			#else 
				程序段 2 
			#endif 
			
				它的功能是如果标识符已被 #define 命令定义过则对程序段 1 进行编译;否则对程序段 2 进行编译。 
				如果没有程序段 2(为空),本格式中的#else 可以没有,即可以写为: 
			
			#ifdef 标识符 
				程序段 
			#endif 
				
		2.2第二种形式如下: 
			#ifndef 标识符（宏名） 
				程序段 1
			#else 
				程序段 2 
			#endif 
			与第一种形式的区别是将“ifdef”改为“ifndef”。
			它的功能是如果标识符未被#define 命令定义过则对程 序段 1 进行编译,否则对程序段 2 进行编译。
			这与第一种形式的功能正好相反。 
		
		2.3第三种形式如下: 
			#if 常量表达式 
				程序段 1 
			#else 
				程序段 2
			#endif 
			它的功能是如果常量表达式的值为真(非 0),则对程序段 1 进行编译,否则对程序段 2 进行编译。 
			因此可以使程序在不同的条件下完成不同的功能。		

			
	3、宏的应用：
		1、防止头文件重复包含
		#ifndef  宏名
		#define  宏名
	
			头文件:外文件声明,类型定义
		
		#endif
		
		2、代码移值（linux下的代码，windows不能执行，反之亦然）
			#ifndef  宏名      
				代码块
			#endif
			PS：如果宏名没有定义，则包含如下代码块
			
			#ifdef 宏名
				代码块
			#endif
			PS：如果宏名定义，则包含如下代码块	
			
			
十一:标准io(输入/输出)

输出：
	
		int putchar(int);输出一个字符,把ch写到STDOUT(标准输出)
					     返回值：被写的字符
		
		int puts(数组名或字符串);输出一个字符串,把str(字符串)写到STDOUT(标准输出)上. puts() 成功时返回非负值, 失败时返回EOF. 

		
		返回字符串长度；
		
	//格式化打印：
		printf("格式化字符串");
	格式化字符串：决定屏幕的输出内容
		组成：普通字符或控制字符组成的输出格式内容
	控制字符：
		%nd		n代表输出的宽度  
		%5d  输出的宽度有5个字符宽度，以右对齐输出
		%-5d 输出的宽度有5个字符宽度，以左对齐输出
		%ns		s输出字符串
		%n.mf	n代表输出的宽度     m代表输出精度
		%nc		输出字符

输入：都是阻塞函数（如果用户不输入并回车，则一直等待）

	输入一个字符
		int getchar(void);
		返回值：读取的键盘上的输入值(ASCII)
	输入一串字符串：	
		gets(数组名);
	格式化输入：
		scanf("%d",块空间的首地址（&a）);
		PS: 除了%c不能加空格分隔输入，其他控制输入必须加空格分开
			%d%d   100  200
			%c%c  ab
			
			long     输入时：%ld
			double   输入时：%lf或%le
			指针：%p：将输入解释成一个指针（地址）
			
Ps:	1.格式字符串(printf)的形式为： % [输出最小宽度] [.精度] [长度] 类型 
	2.scanf() 函数返回成功读入的项目的个数。
		如果它没有读取任何项目(比如它期望接收一个数字而您却输入的一个非数字字符时就会发生这种情况),scanf()返回0。 
	3.当它检测到“文件末尾”(end of file)时，它返回EOF(EOF在是文件stdio.h中的定义好的一个特殊值，
	  一般，#define指令将EOF的值定义为-1)
		
		
十二、c++基础(c里面 没有(注:const  :c99 后才有))

	一、数据：
			变量：
			常量：不可改变的量
			
			常变量：通过const来修饰   		 ： C语言 c11后也有const
			
				const 定义 变量;  //该变量是不允许修改的,这就是为什么需要定义的同时赋初值称为初始化
	
			常指针变量：const char* abc;
			指针常变量：char* const bcd;    
			常指针常变量：  const char* const bc;


	二、C++的取别名	
		1.引用：取别名（等价于它本身，完全相同）：java中，只有引用
			类型&  别名=变量;   引用变量		
				&a    取a变量的地址
				int& aa=b;//aa是b别名
			
				PS:1引用时必须初始化(别名必须初始化)
			
		2.别名指向的变量不可以发生改变 
		
				int& aa=b;
				int c=2;
				aa=c;  --》只是将c的值，赋给aa ， aa引用的是b的空间
					
	三、输入输出：
		1.输入:
		cin>>变量
		
		2.输出：
		cout是一个输出对象，将输出的封装成为类对象

		cout<<数据1<<数据2<<'\n';
		
		PS:1、默认输出10十进制数字
		   2、cout输入字符串遇到‘\0’停止	

	四、函数：就是描述一个功能的过程
			定义函数：不会被执行，只是描述了一个功能过程
			类型 函数名(..)
			{
				...
			}
				
	五、c++中有重载，C语言中没有重载概念
		重载函数：	在同一作用域下定义的同名不同参（1.个数，2.类型，3.顺序）的函数则为重载函数
				
				（静态多态）：在编译时就能确定调用哪一个同名中的具体函数 
				
				PS:函数名不能达到调用，必须还借助形参与实参的匹配。
				
				https://blog.csdn.net/alidada_blog/article/details/80734900
		

	六、函数模板(泛型:类型不确定)：过程一致，但是数据不同
			template<typename T>
			返回类型 函数名(T d1,....)
			{
				...
			}
			Ps:函数名（1,1.2）报错	
	
			template<typename T，typename T1>
			返回类型 函数名(T d1,T2....)
			{
				...
			}
		PS:1、在C++中（重载，函数模板中），
				调用函数时，必须是函数名匹配，
				还要求是形参与实参也要匹配。（同类型，反之：定义两个泛型）
		   2、形参类型与返回值类型可以是泛型，也可以是确定类型。

十三、可变形参
	printf("%d",1);
	printf("%d %d",1,2);
	printf("%d %d %d",1,2,3);
	总结:printf是一个可变形参
	
	1.定义可变形参函数（C语言中也有）（1.va_list 2.va_start 3.va_arg 4.va_end）
		需导入（include<stdarg.h>）
		显示类型以及数目：int num
	
		num:显示后面形参的数量
	
		返回类型 函数名(显示类型数目,...)
		{
			//从参数列表(类似于一个数组)中取值
				va_list ap;
			//1、初始化va_list这个类型（自定义） 将va_list指向实参列表
				//void va_start(va_list ap, last);   
								last：结束的位置 ，参数的个数（num）
			//2循环获取实参
				type va_arg(va_list ap, type); 
						type（类型 如:int）: 根据可变形参，（根据实参类型确定）
			
			//3释放
				void va_end(va_list ap);
		}
		
	PS:显示类型的作用是:一般用于显示传递的参数的个数和类型
		
十四、指针变量及指针运算
		指针: 就是地址(地址:物理内存上连续编号)
		
		指针变量:
				1.定义指针变量：分配空间（地址）
						只能存储指针（地址）（*只能运用于指针）
					
						int* pa = &a;
						pa-->引用p  自身空间  的内容
						*pa----> 引用p指向的空间的内容,（指向的空间（地址）必须存在（分配））
		
						如果该地址空间没有分配则无法使用（int* p=0  --》0的地址空间并没有被分配）
	
						取别人东西      取自己东西
	
				2.初始化指针变量:定义指针变量同时赋初值   
						类型* a=地址; 
						 int* a=&b;
							
							Ps：
								指针中不初始化，为野指针(指向随意的地址)

				3.引用指针变量：
				
					通过变量名来引用
					
					cout<<"*0x8049a78="<<*(int*)0x8049ac4<<endl;//一个十六进制的数强转成一个地址	
					
		3.指针运算:
			
			1.* 指针(&a)   引用该指针  指向的空间  内容
		
		
	
			2.* 指针变量      引用指针地址的长度   是该类型决定
				sizeof(类型)Byte空间	
		
				char* pa=&a;  *pa  引用pa指向的1Byte空间	

				short* pa=&a;  *pa  引用pa指向的2Byte空间		
	
				类型* pa=&a;  *pa  引用pa指向的sizeof(类型)Byte空间	
			
				强转：
					int* pa=&a;
					char* b=(char*)pa;
					
			3.指针和数组结合：（为了和数组结合）

				指针 +/-  n：从指针开始（+）向右 / (-)向左移动到 n个元素后  空间地址
			
				指针 + n*sizeof(类型)  
			
			short  :  每次移动2个byte（short--》（1*2byte））：
			char   ： 每次移动1个byte
			
			
			
			指针-指针：只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。
					   两个指针相减的结果的类型是 ptrdiff_t，它是一种有符号整数类型。
					   减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），
					   因为减法运算的结果将除以数组元素类型的长度。举个例子：
					    int a[10] = {1,2,3,4,5,6,7,8,9,0};
						int sub;
						int *p1 = &a[2];
						int *p2 = &a[8];

						sub = p2-p1;                                                                            
						printf("%d\n",sub);　　　　// 输出结果为 6

			指针+指针
			
			地址-地址  等于两个地址之间元素的个数
			
十五、指针数组，指针与函数以及数组的关系
	
	数组就是一个指针
	
		1.定义指针数组：用于存储指针的数组
			int* buf[长度]={地址,...,...};

			引用/修改空间的内容：
				1、变量名
				2、引用
				3、地址
	
		2.空指针：作为指针 指向的空间不存在的标识
			#define NULL   (int*)0
				
		3.函数与指针联系：
			1、指针作形参：用于调用函数 修改空间值(看到变量名，引用自身空间的内容)
				void swap(int* pa,int* pb)
				{
				
				}
			2、数组作形参：该数组不是数组空间，而是指针变量 
				void show(int buf[]/*int* buf*/)
				{
				
				}
			3、指针作返回类型：该函数的结果为一个指针（地址）
				类型* 函数名（...）
				{
					...
				}
			
十六、二维数组指针,以及函数指针

	一、二维数组与指针：
		二维数组的数组名+n=下n行首地址
		

		定义二维数组指针：
			类型 (*数组名)[m]；//m代表列
			int (*pd)[4];  
				ps:要想找到元素的具体位置，必须清楚  列的坐标

		行指针：(二维数组名  二维指针)  int buf[1][3]    int (*buf)[3]  int** buf; 
			行指针+n   指向n行
		列指针：（一维数组名  一级指针）	：int buf[]       int* buf
			列指针+n   指向n列
			
		PS:想要获取内容，必须获取列地址
		
		
	二、函数指针:就是函数的入口地址	

		定义函数指针变量:
			类型 (*变量名)(形参列表)= 函数名（地址）
			
		函数名就是该函数的入口地址----》 函数名，是一个地址
			int (*指针名)(形参列表);
			
	三、调用函数：
		1静态调用：
			函数名()
		  确定：在编译器编译时确定
			
		2、动态调用：在运行时才能确定调用哪一个函数。
			指针(实参);
				函数指针：
					定义函数指针变量：
						返回类型 (*指针变量名)(形参类型)
						//返回值为int
						int (*pbuf)(int,int);
						
						//返回值为void
						void (*pbuf)(int,int);
		3.函数指针与数组的结合：
	
		
		4.函数指针数组  名字={函数名。。。。。函数名n}；

十七、断言以及重命名类型

	一、断言
	
		断言：assert(条件)：形参为指针是，最好加上断言，防止传入空指针	（!=NULL）
		assert.h
		注：条件为假，则输出提示
		
	二、typedef：已知类型重命名(
								基本类型：整型，浮点型，字符型
								复杂类型：结构体（自定义数据类型）
							)
							
		1、基本类型
			typedef int INT
		2、函数指针类型
			typedef int (*别名)(int,int);
		3、对结构体类型取别名
			typedef struct people   p ；
		4、指针类型
			
十八、结构体及联合体，枚举	
	1.结构体：自定义数据类型（复杂类型）

	定义新的结构体类型(申请一个复杂类型，并不是定义，所以并没有分配空间)
		struct 类型名
		{
			 类型 属性变量1;
			 。。。  
			 
		};
	ps：只有函数指针，没有函数
	
	
	2.联合体(共用体)：
		一般定义 形式为: 
		union 共用体名 
		{ 
			数据类型 成员名 1; 
			数据类型 成员名 2; 
			...... 
			数据类型 成员名 n; 	
		
		}变量名表列; 
		
	3.枚举：
	  定义枚举类型
		enum 枚举类型{值名1=0,值名2,值名3...};
	  定义枚举变量
		enum 枚举类型  变量名=值名;
		
		PS:值名必须来自 定义 枚举值。


		

十九、文件
		1.打开
		FILE* fopen(char* path,char* flags);
		
		2.操作

		文本文件:
					int fputc(int,FILE*)        输出一个字符到文件中
					int fputs(char*,FILE*)  	输出一串字符到文件中
					fprintf(FILE*,char* formatter,...);
					
					int fgetc(FILE*);//获取一个字符
					fgets(char*,FILE*);//获取一串字符
					fscanf(FILE,char* format,...(块空间元素‘&’));
						
					feof(file):feof:文件结束返回 非0，文件没有结束返回 0
					
				
		二进制文件:
		int fwrite(void*m,int size,int mem,FILE*fp);
		int fread(void*m,int size,int mem,FILE*fp);
		
		
		int fseek(FILE *stream, long offset, int whence);
		int ftell(FILE)： 获取读写位置
		
		3、关闭
		fclose(FILE*);
		
二十、默认新参（c++，c中没有）
	
	C++
	调用函数：函数名匹配，实参与形参匹配。
	默认形参：
		定义函数：
	返回类型  函数名(形参1=值，形参2=值，形参3=值。。。)
	返回类型  函数名(形参1=值，形参2=值，形参3=值。。。)
			
			PS:1、默认形参可以给定部分形参
			   2、定义默认形参时，必须按照从右往左给定（且不能间隔）
				  （左边形参给定默认形参，右边形参必须有默认值）
				  
二十一、主函数带参数：
	1、空形参
		int main(void);
		
	2、带形参
		int main(int argc,char* argv[]);
	
		PS:
			形参1：argc代表参数的个数
			形参2：argv参数数组
	
		注：第一个参数代表为执行的路径（./a.out）
		
二十二、堆区
C语言：
		
		申请堆区： void* malloc(size)
				返回值：申请堆区的地址(由于申请空间类型不明确，所以返回空指针)
			
		PS:1必须释放，否则会出现内存泄漏
		   2一个堆区不能释放两次
		   3、堆区的初值为0
		   	   
		(*)通过ｍalloc申请各种类型堆区
			类型* 指针=malloc(长度)
			 
			申请整型空间
				int* p = (int*) malloc(sizeof(int));
			申请数组空间:申请4个元素的int数组空间，须知道列
				int* p=(int*) malloc(sizeof(int)*4);
					//数组必须一个一个赋值，不能整体赋值
			申请二维数组空间  （行列）
				int (*p)[5]=(int (*)[5]) malloc(sizeof(int)*4*5);
			申请结构体空间：
				struct people* p=(struct people*) malloc(sizeof(struct people));

		释放空间:
			free(指针)
			
C++: new  指针，必须申请空间，否则段错误
		1、申请一个元素空间
			new 类型(值)     
		2、申请一块空间（数组）
			new 类型[长度];  //这就不需要使用，求类型长度，因为类型已经明了（和malloc不同点）
		
		3、申请一个对象：通过new 来调用对象的构造器，在堆区分配空间
		     类名* 变量名 = new  类名(...);
			 
			
			
		delete:
		1、释放一个元素空间
			delete 指针
		2、释放一块空间
			delete[] 指针;
		3、释放一个对象:
			delete 对象指针
		