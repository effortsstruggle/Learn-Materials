进程间通信：存在于程间之间的通信
	1、管道
	2、信号
	3、共享内存
	4、消息队列
	5、socket（网络）
	
	
1、网络通信：不同地域之间的主机通信
	目标：资源共享
	
2、网络协议：双方约定的规则；（"iso /osi :理论 ；TCP/IP:(80%网路厂商 );"）   
	协议表示: 三部分
	语法（规定写法）		语义（解释给我们看）		规则：做什么
	IP地址						目的地址					

	ISO  （国际标准化组织 ： International Organization for Standardization）国际标准协议


一、OSI模型（iso）：开放式系统互联通信参考模型（Open System Interconnection Reference Model）
		发送方 							接收方
7		应用层	--------------------	应用层   	Application
6		表示层	--------------------	表示层		Presentation
5		会话层	--------------------	会话层		Session
4		传输层	--------------------	传输层		Transport
3		网络层	--------------------	网络层		Network   				ipv6	
2		链路层	--------------------	链路层		Data Link
1		物理层	--------------------	物理层  	Physical	
	
1、物理层（比特）：设备的标准（网线的接口类型、光纤的接口类型等）  		
		作用：把电脑连接起来的物理手段 （网线，光纤）， 传输比特流（电流、电信号）传输方式
			（该层 数据叫做比特）

2、链路层：数据帧 
	作用:传输格式化数据，通常还提供错误检测和纠正,以确保数据的可靠传输
		
		把特定意义的数据通过物理介质传输给对方,单纯数据时没有意义的，要想有意义需要用字节（0/
		1）为单位,进行分组，表示电流信号信息,
			多台电脑时，用于路径选择
			
3、网络层：数据报  (IP协议，ARP协议，路由协议)
	作用：不同地理位置的网络中的两个主机系统之间提供连接，网络层正是管理这种连接的层
			 简单的说  地址链接
			 
			 1.发送方 如何能接受到mac地址？
			 
			 2.发送者 如何能知道接受者与自己是否属于同一子网？
		IP协议:
			IPV4：4段点分十进制
			IPV6：6段点分十进制
		ARP协议:通过ip地址  找到 mac地址 （路由器  arp表格）
			
4、传输层：报文段/用户数据报
	作用:传输数据的协议和端口号
	
	UDP(user datagram protocol----用户数据报协议)：面向无连接，不安全，不可靠的传输协议（效率很高）   
	TCP（transmission control protocol---传输控制协议）：面向有连接，安全，可靠的传输协议（效率低）

	该层数据称为数据段
	
5、会话层：
		通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。
		主要在你的系统之间发起会话或者接受会话请求；
		（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）
		
6、表示层:可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取，且读懂

			
	例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），
		  而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符
		  如有必要，表示层会通过使用一种通用格式来实现多种数据格式之间的转换
	  
7.应用层：报文 （用户自定义协议）
	  
二、TCP/IP协议	  
	TCP/IP协议：成为了当今的英特网协议, （当今国际标准协议）
		
		两种分层模型:
		
		//1.	4层 模型
		abc					应用层								应用层 		abc
		[1]abc				传输层（TCP/UDP协议）				传输层		[1]abc
		[2][1]abc			网络层								网络层		[2][1]abc	
		[3][2][1]abc	数据链路层(网络接口层，物理链路层)		数据链路层  [3][2][1]abc
		
		//2.	5层 模型
		应用层							应用层
		传输层							传输层
		网络层							网络层	
		链路层							链路层	
		物理层							物理层

		
		上一层为下一层提供数据，下一层为上一层提供服务
		
应用层协议:双方约定的规则
		客户端					服务器
		1#1					关机
		1#2					获取进程列表
		
飞秋：是一款局域网通信程序，基于UDP通信		
		1、给飞秋发送信息：  IP、端口号
		2、飞鸽协议：
				聊天：
					1:100:用户名:主机名:32:聊天内容
					
			飞秋的通信大致过程：
				在线列表：存储局域中上线的用户的信息
				
				服务器端:
				
					1.容器(list),存储用户信息
					2.	
					
					
					1、登录飞秋：向本局域网发送上线通知      6291457
						PS:一当飞秋收到上线通知时，存储信息到在线列表中
				1#1	
						--》1. 一个函数  遍历列表    
							2.	插入数据到列表
							3. 触发一个 “上线通知” (广播)
							运行客户端 --》 发送一个1#1	给服务器
				 2、退出飞秋：向本局域网发送上下线通知
						PS:一当飞秋收到上线通知时，从在线列表中干掉
				1#2		
						--》1. 一个函数  遍历列表    
							2.	删除数据从列表
							3. 触发一个 “下线通知” 
				
						
				1#3	
					3、聊天系统：   288
					
						点聊：从在线列表中选择用户聊天
						
					4、
	
Wireshark:是一款抓包软件，抓取网卡信息 网络上的数据
	如何来过滤:
		http:
		udp.port:
		tcp:
	
	1.常用运算符:
	
		1.相等	eq;	==
		2.大于	gt;		>
		3.小于	lt;		<
			   &amp;	&
		4.且	and 	&&
		5.或	or		||
		
飞秋协议:wireshark  抓取的数据
	1_lbt6_0#128#141877B3DA81#0#0#0#4001#9:1600439688:admin:DESKTOP-3D9OVMF:288:	
	1_lbt6_0#128#E0ACCB8AB708#0#0#0#4001#9:1600444769:win8:APPLE:210:	
	
三、MAC地址（网卡id）  ip地址   端口号	

1.MAC地址：标记网卡的唯一的ID （ 每台主机都以唯一MAC地址 ）

2.IP地址：标记此主机  在网络（internet）上的位置（被分配了一个编号）  

	ipv4（现已枯竭）:  4段点分十进制
			[].[].[].[]    
	IP地址： 网络号+主机号	
			网络号：此主机所在的网络上位置 （主机所在网络上的身份标识）
			主机号：所在此网络下的某台主机
		
	广播地址（...255）:代表此网络下所有主机(创建的套接字 默认是点对点)
	
	192.168.1.0  ： 网络号地址   -- 主机为全为0
	127.0.0.1	：本机地址  不会向外转发，只向本机发送
	
		A  [网络号][[主][机][号]]
			[0...][[主][机][号]]
			0开头	
			1-127
		B   [[网][络号]][[主][机号]]
			[10]开头
			128.0-191.255
		C   [[网][络][号]][主机号]
			110开头 
			
			192.0.0 -223.255.255
			
		D组播：最高位必须是1110
			224
	
		E

3.端口号：程序的网络标识    程序有很多 ， 所以需要指定端口号
	128以下被预留    80：HTTP（超文本传输协议）   FTP:20/21（文件传输协议）    SSH:22（远程连接服务器）   
						telnet：23（远程登录）  SMTP:25（邮件传输协议）  ...
	
			三要素:
				IP地址:标记此主机在网络上的位置

				MAC地址：标记网卡的唯一ID

				端口号:程序的网络标识
					128以下被预留, 80：HTTP   FTP:20/21    SSH:22  SMTP:25  ...
				
四、网络字节序

网络字节序（Endian：字节序）:网络统一规定的网络字节序列
		因为不同处理器，架构不同
	
	1.字节序：数据在存储器中的存放顺序

	端口号转换成网络字节序:	
		htons(short)   端口号用于转换为网络字节序地址
		htonl(long)
	IP地址转换成网络字节序:
		inet_addr("ip"):将字符串车换为网络字节序
			
常用网络API:
		1、将字符串车换为网络字节序
			inet_addr("ip");
		2、将地址网络字节序转换为字符串
			inet_ntoa
		3、将网络端口的字节序转换为主机序
			ntohs			
			
	

	2.高位存储（Big Endian--》大端存储）  还是 低位存储（Little Endian--》小端存储）
		从右（低）往左（高） 
				
		简单来讲所谓的
				大端存储就是将高字节序的内容存在低地址处，低字节内容放在高地址处
				小端存储就是高字节内容放在高地址处，低字节内容放在低地址处
		
		例如： int n=1；
		它的原码，反码，补码都是 00000000 00000000 00000000 00000001
		它在计算机中的小端存储字节序为  00 00 00 01
					  大端存储字节序为 01 00 00 00
					  
		https://blog.csdn.net/oqqHuTu12345678/article/details/82823890


五、传输控制层：
	UDP：面向无连接，不安全，不可靠的传输协议（效率很高）  --》发多少  收多少
		1.不可靠:(1.无法确定信息一定能收到, 2.发送数据顺序可能不一致（让它添加一个标志 ， 1、2、3）,3.)
			那需要如何处理？  Ps:在传输层中，udp的确不可靠,但是可以再应用层让它可靠（）
		
			UDP报文协议:(之所以不可靠，就是因为)
			0		 16 		32	  48  	  64bit
			[源端口号][目的端口][长度][校验和][数据]
			
		UDP通信（数据包）: 
					网络层  添加的报头
			[源ip地址][目的地ip地址][0][17]  [udp长度][源端口号][目的地端口号][长度][校验和]数据
				4byte		4byte 	 1	1 	   2 			2   	   2		2	2				
		
			接收方（服务器）																发送方（客户端）										客户端
		1、创建套接字（ ：数据包式套接字）																		1、创建套接字
			int socket(，，0);  0：同步
				domain:网络族（域，网络领域）
				
		2、绑定套接字（必须绑定：公布端口号:）									2、绑定套接字（可以不绑定）
				INADDR_ANY  -- 本机网卡(地址)
			bind();
		3、收 发信息																		3、收发信息
			sendto/send（Tcp）
			recv(Tcp)/recvfrom：阻塞函数
		4、关闭																				4、关闭
			close();
		
		Ps: 接收方必须绑定原因:发送方发送信息,需要知道接收方IP地址和端口号，
		
		
	TCP：面向有连接，安全，可靠的传输协议（效率低） --》 数据基于流的传输
		1.给数据序号（解决顺序不一致情况）
		2.ACK机制（收不到，就重新再发），确定
		
		服务器										客户端	
		1.创建套接字（打开网络，流式套接字）		1.创建套接字
			socket()
		2.绑定套接字								2.绑定套接字
			bind
		3.监听										3.主动连接
			listen
		4.等待连接									4.收发信息
			accept();
		5.收发信息									5.关闭
			send / recv
		6.关闭
			close
			
		Ps：在Windows下，需要初始化SOCKET环境（WSAStartup），使用完毕后再关闭SOCKET环境（WSACleanup）
		
		TCP:常见问题（多个数据包） 
		
		粘包:如下两个方面会导致粘包(多个数据包粘在一起)
			1.发送方：连续发送多个数据包 ， 发送方 等待多个数据包 归并一起发送
			2.接收方：因接收方接受不及时，网卡收到多个数据 会粘到一起
			
			//什么时候需要解粘包
				1.若所有数据包来自于一个完整的数据时，此时不需要处理
				
				2.若接收的数据包来自于多个数据时（并行），必须处理粘包
		
		解决tcp粘包:
			1.底层:关闭Nagle算法（不可行） ， 不可靠
			应用层:
			2.应答机制（ACK）： 你一发送，我就回答，你没有接收到回答，我就不能在发送
			
			3.协议处理:每个报文加长度（把消息的尺寸与消息一块发送）
						使用特殊标记来区分消息间隔

						发送固定的消息长度
		
	
	
	Ps: 面向连接，可靠 ， 粘包问题解析
		1、
			TCP：面向连接的，面向流的  发送端为了将多个发往接收端的包，更有效的发到对方，
			使用了优化方法（Nagle算法 --> 合并算法），
			将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。
			这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。
			即面向流的通信是无消息保护边界的。
			
			UDP:是无连接的，面向消息的，提供高效率服务。
				不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，
				所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，
				在每个UDP包中就有了消息头（消息来源地址，端口，数据长度等信息），
				这样，对于接收端来说，就容易进行区分处理了。
				即面向消息的通信是有消息保护边界的。
	
	
		2.TCP可靠:(通过序列号（ACK）和确认号)
		
			每个  Tcp socket 在内核中分别有一个发送缓冲区和接收缓冲区，
			发送方---发送数据---》接收方   
		
			1、接收方接收到数据，会给发送方返回一个（ACK回执），
				如果发送方没有接收到正确的ACK，
				就会重新发送数据直到接收到正确的ACK
				
				发送方发送的数据序号是seq , 那么接收方 返回 seq+1 作为 ACK 给接收方
				那么下次发送方就发送数据序号是 seq+1 给接收方
				
			2.TCP ACK优化：
				TCP如果每一个数据包都发送ACK，
				就会有大量的网络资源消耗在ACK的发送上，不合算
				所以，TCP设计了延迟ACK机制  
				
				优化：
					客户端一次给服务器发送多个数据包，当服务器接收到数据包时，不马上发送ACK,而是稍微等一段时间，在等待过程中，可能接收到后续几个数据包，服务器直接按最后一个正确数据返回 ACK,给客户端减少发送ACK总数
				当发送错误时:
					a、超时重传机制
					b、快速重传机制
					
			2.流量控制:让发送方的发送速率不要太快
				"滑动窗口机制"可以很方便的在TCP连接上实现对发送方的流量控制
				
				滑动窗口:
					TCP的"窗口单位"是字节，不是报文段，
					发送方的发送窗口 不能超过 接收方给出的接收窗口 的数值
				
				发送方通过维持一个发送"滑动窗口" 来确保
				不会发生由于发送方报文发送太快接收方无法及时处理的问题。
		

		3.粘包原因:
			1.UDP是有消息保护边界的，消息保护边界（数据独立）-->将数据作为一条独立消息在网络中传输，而接收端只接收独立的消息
				也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包
				
			2.TCP：面向流的（无消息保护边界），发送端如果连续发送数据，接收端有可能在一次动作中接收两个或多个数据包
					Ps:将数据当做一串数据流来传输


			
地址复用，广播地址：	(若该端口进程正在运行，还是会绑定失败)	

	修改套接字属性：
		int setsockopt(int sockfd, int level, int optname,
					  const void *optval, socklen_t optlen);
			形参：
				套接字sockfd
				level:层次
					SOL_SOCKET
				optname:设置的选项
					SO_REUSEADDR   地址复用
					SO_BROADCAST   广播
				optval:
					
	获取套接字属性：
		getsockopt()

网络编程模式：
C/S：Client/Server
Client客户端：发送请求方
server服务器：接收客户端的请求，并响应处理

	struct sockaddr
	{
				sa_family_t sa_family; //地址族
				char sa_data[14];	//地址+端口  --》 一个序列，填充比较麻烦，所以用下面的拆分后的结构体
	};
	struct sockaddr_in
	{
				sa_family_t sin_family; //地址类型（一个簇群）
				struct in_addr  sin_addr;//网卡类型（地址）
				char sin_port[4];//端口
				char prot[4];
	};
		
	
	struct in_addr
	{
		uint32_t s_addr;
	}
	
	

练习：
	1、熟练今天的内容
	2、多进程并发
	3、完成聊天室：
		客户端					服务器：
		  发送：你好----------》收到：你好
		  收到：你好《-----------发送：你好			

	4、设计协议：  解析字符串
		客户端					服务器：
		  1#1					  关机     system("halt");
		  1#2					  给客户端返回进程列表(子进程，管道，dup2)
		  1#3#进程名			  干掉此进程名的进程(killall)
		  
周末任务：
	1、熟练今日知识点（1、控制系统  2飞秋聊天）
	2、完成项目：聊天系统