IPC：进程间通信 
  1、匿名管道（读写两端）：半双工（是存放在内存中的一个特殊的文件结构）
		int fd[2];
		1、创建匿名管道
				int  pipe(int fd[])
			形参：
				fd存储读（fd[0]） / 写 (fd[1])端  文件描述符
			返回值：成功>0  失败<0
			
			
		PS:1、单向
		   2、应用父子进程(有关系的进程) 
		   3、管道破裂(断开)：
				1、创建管道成功，写入端进程先关闭写入端时，读取端进程读取没有意义，读取时失败（read返回-1），直接返回不等待。
				2、创建管道成功，写入端进程保持写入端打开，读取端进程读取信息时，若管道中没有信息则等待管道信息中有信息被写入，否则一直阻塞。
				
				3、创建管道成功，读取端进程优先于关闭读取端，写入进程写入信息没有意义，写入失败。
				4、创建管道成功，读取端进程不关闭读取端，写入端进程也不关闭写入端，但是写入端一直写入信息时达到管道为满时，写入端写入被阻塞。
				
		eg: 考察：匿名管道，重定向
			 cat a.txt  |  grep -i  LIFEI  
				标准输出	标准输入
				
  2、命名管道:是一个特殊的文件(存放在外存中)   同步
		特点：每个FIFO文件都有一个路径名与之对应，从而允许不同关系进程可以实现通信
		1、创建命名管道：
				int mkfifo(const char *pathname, mode_t mode);   
				形参:
					pathname:路径
					mode:文件权限
				返回值：
						成功 0
						失败-1
							errno 
								EEXIST 因为创建的文件存在
								
								
		2、文件的操作步骤：
			1、打开
			2、操作
			3、关闭
	PS：
		1、若写进程打开，但读进程不打开，则写进程阻塞在open   等待读进程打开
		2、若读进程打开，但写进程不打开，则读进程阻塞在open  等待写进程打开
		3、若读写都打开时，不写入消息或者文件为空时，阻塞读，直到有信息写入
		4、若读写都打开时，写入端直接退出时，读取端直接读取信息直到信息读完时  不阻塞等待。
		
		eg:
			完成本电脑通信：
						1、A程序：收信息，发送信息
						2、B程序：收信息，发送信息
			完成遍历文件效果：
				A(服务器）《-------》C(/home/LF)
			完成通信拷贝：
				A---->B发送文件内容
		
  3、共享内存:允许两个不同的进程（没有关系）共享一个的存储区（逻辑内存）。
			当一个进程改变了这块地址空间的内容时，其他进程也会察觉到相应内容的改变。
			数据直接写入到内存，不用若干次拷贝（是所有IPC中最快的通信）
			
			共享内存步骤:
					1.生成唯一键值:ftok()
					2.创建共享内存:shmget()
					3.地址映射:shmat()
					4.使用:给地址空间赋值 (strcpy)
					
			1、生成唯一key值
				1.ftok函数生成键值
					每一个共享内存都有一个对应的键值（key）相关联（消息队列、信号量也同样需要）。
					所需头文件#include<sys/ipc.h>
					函数原型 key_t ftok(const char *path ,int id);
						1.形参:
						path为一个已存在的路径名
						
						id为0~255之间的一个数值，代表项目ID，自己取
						2.返回值:
							返回值：成功返回键值（相当于32位的int）。出错返回-1
					例如：key_t key = ftok( “/tmp”, 66);
					
			2、创建共享内存，返回内存标号，标识符
				int shmget(key_t key, size_t size, int shmflg);
				1.形参
					key:生成的唯一key值
					
					size：共享内存的大小，以字节为单位(自己指定)
					
					shmflg:（IPC_CREAT|0664）
						flag为所需要的操作(operator)和权限(permission)，可以用来控制创建一个共享内存。
							操作：
							flag的值为IPC_CREAT：
									1.如果不存在key值的共享内存，且权限不为0，则创建共享内存，并返回一个共享内存ID。
									2.如果存在，则直接返回共享内存ID。

							flag的值为 IPC_CREAT | IPC_EXCL：
									1.如果不存在key值的共享内存，且权限不为0，则创建共享内存，并返回一个共享内存ID。
									2.如果存在，则产生错误。
							权限（permission）：
								最低有效位来定义共享内存的权限（注：执行权限不被使用）
		
				2.返回值:
					返回值：成功返回共享内存ID；出错返回-1  
							如果创建存在，则直接返回内存编号
							
							
					errno != EEXIST :忽略已经创建，所造成的失败

			3、地址映射：将物理地址映射到逻辑地址 （逻辑空间连接到当前进程的地址空间）
				void *shmat(int shmid, const void *shmaddr, int shmflg);
				
					shmid：由shmget()函数返回的共享内存标识。

					shmaddr：指定共享内存连接到当前进程中的地址位置，
							通常为空，表示让系统来选择共享内存的地址。

					shmflg ：一组标志位，通常为0。
							如果在shmflag中指定了SHM_RDONLY位,则以只读方式连接此段，否则以读写的方式连接此段

			返回值:
				调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.
				
			4、操作（读，写，删除）,给地址空间赋值
				strcpy()....等等。
			
		优点：快，方便
		缺点：没有提供同步机制
		
		3、shmdt()函数    -- dt：detach

			该函数用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，
			只是使该共享内存对当前进程不再可用。它的原型如下：
			
			int shmdt(const void *shmaddr);

				参数shmaddr是shmat()函数返回的地址指针，调用成功时返回0，失败时返回-1.	

		4、shmctl()函数    -- ctl：control

			与信号量的semctl()函数一样，用来控制共享内存，它的原型如下：
			int shmctl(int shm_id, int command, struct shmid_ds *buf);
			第一个参数，shm_id是shmget()函数返回的共享内存标识符。
			
			第二个参数，command是要采取的操作，它可以取下面的三个值 ：
				IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。
				IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值
				IPC_RMID：删除共享内存段
			
			第三个参数，buf是一个结构指针，它指向共享内存模式和访问权限的结构。


  4、消息队列
   
	PS: ipcs命令  查看共享内存、消息队列等信息列表。
		ipcrm -q ：删除消息对列
  5、Socket
  
  
  
  
  
  
  
  