算法:
  评价一个算法的标准：1、时间度 2、空间度 3、稳定性强  4、至少一个输入输出
		O(n)=(最高指数)  1n^2+3n+10

  查找最值：监哨值法
		从一块元素中，查找出最大值。 1 3 2 5 10 4 7 13  -3 6 8 9 
		思想：从左往右逐一访问，将“哨兵”指向当前最大值（只要比哨兵大/小就更新）
	
  查找：
	  二分查找（折半查找）：前题有序（升/降）     
		1、每次取区间的中间值进行比较，  （升序）  1 2 3 4 5 6 7 8 9  key=8
		2、	key>mid,查找的值在右侧             
		    key<mid,查找的值在左侧
			key=mid,查找成功
		3、重复1，2步骤直到查找成功或失败（区间不存在:left>right）
	  
  排序：
	冒泡:两两相邻之间比较大小，大的交换（大-》小排序）  ：执行效率较低
	选择:每次从未排序元素中选择最值，依次存放
	插入
	快排：
		1.找一个基准数（就找数组中第一个数）
		2.从两端探测，先从右往左找一个小于基准数的数，再从左往右找一个大于基准数的数
			（结果：左边比基准数小，右边比基准数大）
			
			Ps:因为基准数在最左边，所以让右边先动（这一点很重要）
			
	堆排
字符串处理函数：（笔试）
	//定义求字符串长度的函数
	int strlenmy(char  buf[100])
	{
			//1断言
			assert(buf!=NULL);
			int i=0;
			while(buf[i]!='\0')
					i++;

			return i;
	}
	拷贝字符串：strcpy(des,src);将src拷贝到des中
	
	比较字符串：strcmp(str1,str2);
		str1>str2  返回1
		str1=str2  返回0
		str1<str2  返回-1
		
	连接字符串：strcat(str1,str2);
		将str2的内容拼接到str1末尾
		
	查找字符串：
		strstr(const char* src , const char* str);
	查找字符串：
		1、判断子字符第一次出现的位置
			strchr(buf,ch);
		2、判断子字符串
		char *strstr(str,substr);//判断substr字符串是否存在于str中,返回地址

算法与结构：
数据结构分类:
	1、物理结构：数据在内存中的存储结构
		1.1顺序结构：在一块连续的空间（物理空间相邻：数组）
				优点：访问方便（快速）  下标法
				缺点：插入和删除麻烦,空间不能动态扩容
				
		1.2链式结构：数据不必紧挨在一起，（物理空间不相邻）
				优点：插入和删除方便
			
			1、单向链表：每一个节点只记录下一个节点的地址

				struct Node
				{
					dataType data;
					Node* next;
				};

				class List
				{
				public:
					insert（）
					delete（）
					size（）
					sort（）
					...（）
				private:
					struct Node* head;//头节点
				}
			2、多向链表：
				双向链表：
				
				多向链表：
	
	2、逻辑结构：数据之间的联系（表现形式）
	
	2.1散列：数据之间没有联系	
		
		2.2线性结构：数据之间存在1：1的联系。
			
			除了头节点与尾节点，每一个节点都只有一个直接前驱，和一个直接后驱。头节点只有一个直接后驱，尾节点只有一个直接前驱
			顺序表：数组
				
			链式线性表：1：1
				头插法：每一个新的节点插在链表的开头
				尾插法：每一个新的节点插在链表的尾巴
			 添加节点步骤：
				1、申请空间
				2、填充数据区
				3、修改指向域
			
				单向链表：前驱节点，记录它的直接后驱的节点地址
				  定义节点：
					struct Node
					｛
						eleType data;//数据区
						struct Node* next;//指向区
					｝
					
				双向链表：
				
				循环链表：
				
		 2.2.1顺序线性表:将所有节点存放在同一块空间，
				顺序队列：
				顺序栈
		 2.2.2链式线性表:元素存在1比1的联系
				
		2.3树形结构：数据之间存在1:N的联系
			（族谱或文件系统）
		  2.3.1  顺序树形结构
		  2.3.2  链式树形结构
		2.4图形结构：数据之间存在N:N的联系	
			  应用：地图，高铁关系网
		   2.4.1：顺序图
		   2.4.2：链式图
  链表：
	单向链表：
	单向循环链表：
		头插法：每一个新的节点插在链表的开头
		
		尾插法：每一个新的节点插在链表的尾巴
				1.申请节点
				2.填充数据域
				3.修改指向域（新的节点成为尾节点）
		节点：
		struct Node
		{
			type Data;
			struct Node* next;
		};
	双向链表：
  栈（也叫堆栈）：
	顺序栈：（数组）
	链表栈：
  队列：
	顺序队列：（数组）
	双向对列：
	链表队列：

  树：
	
  图：


栈（也叫堆栈）：数据操作是先进后出(FILO)的思想
   只允许在同一端操作（进出），每次只有一个数据被操作。数据的主要特点：先进后出（FILO）


    应用：恢复与撤消，递归（熟练）,判断优先级
	概念：（模型：一口#）―
		栈顶：能被操作的一端
		栈底：不能被操作的一端
	常用操作：
				struct stack 
				{
					stackType buf[长度];	//容器
					int top;	//指向栈顶元素下标
				}
					
			初始化栈： 将下标设置为-1
				InitStack
			栈是否满
				isFull
			栈是否为空
				isEmpty
			出栈：
				pop
			取栈顶：
				getTop
			压栈：
				push
			栈元素个数：
				StackLength
			清空栈
				clear
			
		
	顺序栈：所有元素存放在同一块空间中，数据元素是采用FILO
	
	链表栈：

队列：允许数据在两端操作，用于出队一端叫队头，用于进队另一端叫队尾。数据操作的特点：FIFO
   队尾：进队
   队头：出队   
	顺序队列：在同一块空间存储该队列中的所有元素
		定义队列：
			#define MAXSZIE 10
			struct queue
			{
				elemType buf[MAXSZIE];
				int front;//队头下标
				int rear;//队尾下标
			};
		 操作：
			初始化队列：initQueue
				front=rear=0
			队满：isFull
				条件：(rear+1)%MAXSZIE=front
			队空： isEmpty
				条件：front=rear
			进队：EnQueue
			出队：DeQueue
			队长：QueueLength
				
		链式队列：

		
		
字符串的操作：
头文件： string.h
  比较:(逐个字符比较)按照字符串的词典序列比较大小
	 系统函数： int strcmp(char*s1,char*s2)  
		s1>s2   >0
		s1==s2  =0
		s1<s2  <0
  长度:
	unsgined int strlen(char*)
	char buf[100]="hello";
	一个数组空间长度：100
	数组元素的个数：5    '\0'结束字符
  拷贝 char* strcpy(s1,s2);
	将s2的内容逐位到拷贝s1，且包括结束字符
	
  连接
  
  
 
 
栈的应用：  
	1、判断优先级（高级功能计算机）
		中缀表达式：
				操作数 运算符 被操作数   1 + 1
		前缀表达式：自学
				+ 1 1
		后缀表达式：李飞
				1 1 +
			
		
	中缀-->后缀：	
		中缀表达式：5+(3*4-2)
		转换规则：
			1、从左往右遍历字符串表达式、
			2、是数字则成为后缀表达式一部分
			   是运算符则按如下规则处理：
					1、若为空栈，直接进栈
					2、是（直接进栈(注："("优先级最高   )
					   是）则出栈顶直到遇到(为止
					3、若当前运算符优先极低于或等于栈顶的优先级：出栈直至高于栈顶元素
						若当前运算符优先极高于栈顶的优先级时，进栈
			3、重1、2步骤直至字符串结束 
	后缀-->计算：
		后缀表达式：534*2-+	
		计算规则：
			1、从左往右遍历字符串表达式
			2、若是数字，则进栈(push)
			   若是运算符：则取栈顶(操作数）与次栈顶（操作数）进行运算结果，再次将结果进栈
			3重复1.2步骤，直至运算完成。
		
		
		
		
		
		

