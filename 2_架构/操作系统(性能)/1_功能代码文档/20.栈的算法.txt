1、常用思想：
	1累加法：
		应用场景：多个元素连续相加/减/除/除

	  1、定义一个容器count：用于存储元素值
		 前题：加减初始为0  乘除：1
		coutn+=元素;	
	  eg:	
		求1-100的和
		求第n项的阶层
		求前n项的阶层和
	2、取十进制的个位
			num%10
			舍弃个位
			num/10
		eg：倒置输出一个整型值
	3。判断值为n的倍数：
		值%n==0
		eg:输出1-100的偶数
	4、交换两个元素的值：
		int a=1 ,b=2
		临时变量：
			temp=a;
			a=b;
			b=temp;
		数学交换法：
			a+=b;
			b=a-b;
			a-=b;
		
 
4、监哨值：从多个未序元素中取出最值
	  (哨兵指向最值)
	  1、遍历元素
	  2、与哨兵比较  ：  当前值>哨兵     哨兵=当前值
						 当前值<=哨兵    ...
	  3、重复1、2步骤直到所有元素完成。
	  PS:哨兵必须初始化为一个元素值

	
5、排序：
	选择：从未排序中选择最值，依次存放。
	/1 4 3 2 6 5 7 0 8		
				   
	从小到大：
	 0/1 3 2 6 5 7 4 8		listen=7
	 0 1/2 3 6 5 7 4 8		listen=3
	



6、栈和队列
	栈：（FILO）元素采用先进后出的规则			（井的模型）
		场景应用：撤销与恢复，递归	
	
	操作：
		1、栈顶：允许被操作的一端
		   栈底：不被允许操作的一端
		   栈为空： top==-1
		   栈为满:  top==MAXSIZE
		   
//第一步：定义栈

	栈的类型：
		struct stack
		{
			type buf[N];//容器
			int top;	//栈顶
		};
//第二步:实现栈的功能
	功能：
		1、判断栈是否为空  
			bool isEmpty()
				空：true   非空:false
		2、判断栈是否为满 
			bool isFull()
				满：true   非满:false
		3、获取栈的长度
			int stackLength();  c++中的：size()
		4、进栈
			push
		5、出栈
			pop
		6、取栈顶元素
			gettop();
//第三步：main函数调用
				main()
		
		
		
		
		
评价一个算法的好坏：
		1、空间度:为了完成这个任务，用的临时空间越少，空间度越高
		2、时间度:执行一次指令的度为1
	
		1 2 3

	
	
	
	
	